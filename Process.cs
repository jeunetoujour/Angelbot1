using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using MemoryLib;
using System.Runtime.InteropServices; 

namespace RiftLibrary
{
    /// <summary>
    /// AION process handler.
    /// </summary>
    public class RiftProcess
    {

        #region Structs



        /// <summary>
        /// Contains base addresses for AION's essential modules.
        /// </summary>
        public struct ModuleBase
        {
            public int Game;
            public int CryEntitySystem;
            public int Cry3DEngine;

        }
        #endregion

        /// <summary>Handle of current AION process.</summary>
        public static IntPtr handle;
        /// <summary>Contains base addresses for AION's essential modules.</summary>
        public static ModuleBase Modules;
        /// <summary>Address of player's macro slot 1</summary>
        public static int macro1;
        /// <summary>Handle of current AION window.</summary>
        public static IntPtr whandle;
        public static ModuleBase modBase;

        private static int currentPid = 0;

        public static int PID 
        {
            get 
            {
                return currentPid;
            }
            
        }
        public static void UpdateModules()
        {
            Modules.Game = GetModuleBase("rift.exe");
            Modules.CryEntitySystem = GetModuleBase("CryEntitySystem.dll");
            Modules.Cry3DEngine = GetModuleBase("Cry3DEngine.dll");
        }

        /// <summary>
        /// Open current AION process for reading/writing.
        /// </summary>
        /// <returns>TRUE if success.</returns>
        public static bool Open()
        {
            currentPid = Memory.GetProcessIdByProcessName("rift.exe");
            handle = Memory.OpenProcess(currentPid);
            whandle = Memory.FindWindowByProcessId(currentPid);
            UpdateModules();
            return (handle != IntPtr.Zero);
        }
        /// <summary>
        /// Open AION process by pid for reading/writing.
        /// </summary>
        /// <param name="pid">Process ID.</param>
        /// <returns>TRUE if success.</returns>
        public static bool Open(int pid)
        {
            handle = Memory.OpenProcess(pid);
            currentPid = pid;
            whandle = Memory.FindWindowByProcessId(currentPid);
            if((uint)whandle != 0 )
                UpdateModules();

            return (handle != IntPtr.Zero);
        }




        /// <summary>
        /// Closes handle generated by Open().
        /// </summary>
        /// <returns>TRUE if success.</returns>
        public static bool Close()
        {
            return Memory.CloseHandle(handle);
        }

        public bool FindAndKillProcess(string name)
{
        //here we're going to get a list of all running processes on
        //the computer
        foreach (Process clsProcess in Process.GetProcesses()) {
                //now we're going to see if any of the running processes
                //match the currently running processes by using the StartsWith Method,
                //this prevents us from incluing the .EXE for the process we're looking for.
                //. Be sure to not
                //add the .exe to the name you provide, i.e: NOTEPAD,
                //not NOTEPAD.EXE or false is always returned even if
                //notepad is running
                if (clsProcess.ProcessName.StartsWith(name))
                {
                        //since we found the proccess we now need to use the
                        //Kill Method to kill the process. Remember, if you have
                        //the process running more than once, say IE open 4
                        //times the loop thr way it is now will close all 4,
                        //if you want it to just close the first one it finds
                        //then add a return; after the Kill
                        clsProcess.Kill();
                        //process killed, return true
                        return true;
                }
        }
        //process not found, return false
        return false;
} 

        /// <summary>
        /// Gets base address of module.
        /// </summary>
        /// <param name="modulename">Module to get base address of.</param>
        /// <returns>Base address if module found, else 0.</returns>
        public static int GetModuleBase(string modulename)
        {

            System.Diagnostics.Process HandleP = System.Diagnostics.Process.GetProcessById(currentPid);

            foreach (System.Diagnostics.ProcessModule Module in HandleP.Modules)
            {
                if (modulename == Module.ModuleName)
                {
                    return Module.BaseAddress.ToInt32();
                }
            }
            return 0;
        }


    }
}
